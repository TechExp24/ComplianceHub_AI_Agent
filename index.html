<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Compliance Agent</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- silence favicon 404 -->
  <link rel="icon" href="data:,">
  <style>
    :root{ --bg:#F7F8FC; --panel:#FFF; --ink:#2C3142; --muted:#8C95A6; --brand:#4F8CF3;
           --radius:18px; --shadow:0 10px 28px rgba(55,97,194,.12); }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
      font-family:ui-sans-serif,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans");}
    .wrap{max-width:1040px;margin:0 auto;padding:18px 14px;}
    .hero{position:relative; display:grid; place-items:center; min-height:60vh; border-radius:var(--radius);
      background: radial-gradient(1200px 600px at 50% 0%, #EAF3FF 0%, transparent 55%),
                  radial-gradient(900px 540px at 0% 100%,  #F4FFF6 0%, transparent 55%),
                  radial-gradient(900px 540px at 100% 100%,#FFF1F7 0%, transparent 55%);
      overflow:hidden; touch-action:manipulation;}
    canvas#waves{position:absolute; inset:0; width:100%; height:100%; display:block;}
    .voicebar{ position:absolute; top:14px; right:14px; z-index:5; display:flex; align-items:center; gap:6px;
      background:var(--panel); border:1px solid #E8ECF6; border-radius:999px; padding:8px 10px; box-shadow:var(--shadow);}
    .voicebar button{border:0;background:#fff;border-radius:999px;padding:6px 10px;box-shadow:var(--shadow);cursor:pointer}
    .voice-name{font-weight:700;font-size:13px}
    @media (max-width:640px){ .voicebar{left:50%; right:auto; transform:translateX(-50%);} }
    .tapOverlay{position:absolute; inset:0; cursor:pointer; z-index:4;}
    .orb-wrap{ width:clamp(200px, 52vw, 360px); aspect-ratio:1/1; z-index:2; filter:drop-shadow(0 15px 40px rgba(0,0,0,.08)); }
    canvas#orb{width:100%;height:100%;display:block;border-radius:50%;}
    .mini-orb{ width:48px; height:48px; border-radius:50%; overflow:hidden; }
    canvas#miniOrb{ width:48px; height:48px; }
    .chips{position:absolute; bottom:14px; left:0; right:0; z-index:3; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; padding:0 10px;}
    .chip{background:var(--panel); border:1px solid #E8ECF6; color:var(--muted); padding:8px 12px; border-radius:999px; font-size:12px; box-shadow:var(--shadow); white-space:nowrap;}
    .live{position:absolute; left:50%; transform:translateX(-50%); bottom:96px; z-index:3;}
    .fab{position:fixed; right:16px; bottom:16px; z-index:50; background:#fff; color:var(--ink);
      border:1px solid #E7EBF5; box-shadow:var(--shadow); border-radius:999px; padding:12px 16px; font-weight:700; cursor:pointer;}
    @media (max-width:640px){ .fab{left:50%; right:auto; transform:translateX(-50%);} }
    .drawer{ position:fixed; left:0; right:0; bottom:-100%; z-index:60; background:var(--panel);
      border-top-left-radius:18px; border-top-right-radius:18px; border:1px solid #E8ECF6;
      box-shadow:0 -12px 32px rgba(0,0,0,.08); transition:bottom .35s ease;
      max-height:92vh; display:flex; flex-direction:column; }
    .drawer.open{bottom:0;}
    .drawer-header{padding:10px 12px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #EEF1F8;}
    .drawer-title{font-weight:800; display:flex; align-items:center; gap:10px;}
    .drawer-content{padding:12px; overflow:auto; display:flex; justify-content:center;}
    .drawer-inner{width:100%; max-width:860px;}
    .grid{display:grid; grid-template-columns:repeat(auto-fill,minmax(260px,1fr)); gap:10px; margin-top:10px;}
    .card{border:1px solid #E9EDF6; border-radius:12px; padding:12px; background:#fff;}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; background:#EFF5FF; color:#2A60D8; font-size:12px; margin-left:6px;}
    .muted{color:var(--muted); font-size:13px;}
    a{color:#2A60D8; text-decoration:none;}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .inputbar{position:sticky; bottom:0; background:#fff; padding:12px 0 2px; margin-top:10px;}
    .input{display:flex; gap:8px;}
    .input input{flex:1; padding:12px; border:1px solid #E1E7F2; border-radius:12px; background:#fff;}
    .btn{border:0; border-radius:999px; padding:12px 16px; background:#fff; box-shadow:var(--shadow); font-weight:600;}
    .btn.ghost{box-shadow:none;border:1px solid #E7EBF5;background:transparent}
    .mic-mini{border:1px solid #E7EBF5; background:#fff;}
    @media (max-width:640px){ .wrap{padding:14px 10px;} .hero{min-height:56vh;} .grid{grid-template-columns:1fr;} }
    @media (min-width:1000px){ .drawer{ left:50%; transform:translateX(-50%); width:min(900px, 94vw); border-radius:18px; } .drawer.open{ bottom:24px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hero" id="hero">
      <canvas id="waves"></canvas>

      <!-- voice chooser -->
      <div class="voicebar" id="voiceBar" title="Change voice">
        <button id="prevVoice">‚óÄ</button>
        <span class="voice-name" id="voiceName">Voice</span>
        <button id="nextVoice">‚ñ∂</button>
        <button id="previewVoice" class="btn">Preview</button>
        <button id="saveVoice" class="btn" style="display:none;">Save</button>
      </div>

      <div class="orb-wrap"><canvas id="orb" width="640" height="640"></canvas></div>
      <div class="chip live" id="liveCaption">Tap to speak</div>

      <div class="chips">
        <div class="chip" id="chipState">Idle</div>
        <div class="chip" id="chipMic">Mic: ‚Ä¶</div>
        <div class="chip" id="chipSR">SR: ‚Ä¶</div>
        <div class="chip" id="chipLevel">Level: 0.00</div>
        <div class="chip" id="chipTZ">Loading‚Ä¶</div>
      </div>

      <div class="tapOverlay" id="tap" aria-label="Tap to speak"></div>
    </div>
  </div>

  <button class="fab" id="openDrawer">üí¨ Chat & transcripts</button>

  <div class="drawer" id="drawer" aria-modal="true">
    <div class="drawer-header">
      <div class="drawer-title">
        <div class="mini-orb"><canvas id="miniOrb" width="96" height="96"></canvas></div>
        Chat & transcripts
      </div>
      <div class="row">
        <button id="drawerMic" class="btn mic-mini">üéôÔ∏è Tap to speak</button>
        <button id="clearChat" class="btn ghost">üßπ Clear chat</button>
        <button id="closeDrawer" class="btn" style="padding:8px 12px;">‚úï Close</button>
      </div>
    </div>
    <div class="drawer-content">
      <div class="drawer-inner">
        <div class="row" style="gap:6px;">
          <button id="btnPing" class="btn ghost">üîå Test API</button>
          <button id="btnSample" class="btn ghost">üß™ Sample query</button>
        </div>
        <div id="feed" style="margin-top:8px;"></div>
        <div class="inputbar">
          <div class="input">
            <input id="text" placeholder="Type a question‚Ä¶" />
            <button id="send" class="btn">Send</button>
          </div>
          <div class="muted" style="margin-top:6px">You can keep this open and continue talking or typing.</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ====== CONFIG (edit API_BASE) ====== */
const API_BASE = 'https://script.google.com/macros/s/AKfycbxZ5PsA_5d2jkE6n5W3tqLro08rvJqp5JtX88I039JdTPCbTH1_VzAtwi8BGFwd_euUjQ/exec';
const USE_SERVER_TTS = true;       // set true if you added TTS_API_KEY in Apps Script
const GREET_ON_FIRST_TAP = true;
const AUTO_TURN_TAKING = true;
const TURN_TAKE_DELAY_MS = 1000;

/* ====== JSONP (avoids CORS; Apps Script redirects with 302 ‚Üí echo) ====== */
function jsonp(url){
  return new Promise((resolve, reject)=>{
    const cb = 'cb_' + Math.random().toString(36).slice(2);
    const s = document.createElement('script');
    const cleanup = ()=>{ try{ delete window[cb]; }catch(e){} try{s.remove();}catch(e){} };
    window[cb] = (data)=>{ cleanup(); resolve(data); };
    s.onerror = (e)=>{ cleanup(); reject(e); };
    s.src = url + (url.includes('?')?'&':'?') + 'callback=' + cb;
    document.body.appendChild(s);
  });
}
const API = {
  meta: () => jsonp(API_BASE + '?api=meta'),
  nlp:  (q)  => jsonp(API_BASE + '?api=nlp&q=' + encodeURIComponent(q)),
  tts:  (persona, text) => jsonp(API_BASE + '?api=tts&persona=' + encodeURIComponent(persona) + '&text=' + encodeURIComponent(text))
};

/* ====== Tunables (VAD) ‚Äì softer so it doesn‚Äôt cut off too soon ====== */
const MIC_NOISE = 0.04;
const MIC_GAIN  = 10;
const MIC_SMOOTH= 0.18;
const LISTEN_MAX_MS = 12000;       // overall hard cap
const INITIAL_GRACE_MS = 3000;     // don‚Äôt stop for first 3s if no speech yet
const SILENCE_START_THRESHOLD = 0.07;
const SILENCE_HOLD_MS = 1200;

/* ====== Mic & SR status ====== */
const chipMic = document.getElementById('chipMic');
const chipSR  = document.getElementById('chipSR');
const chipLvl = document.getElementById('chipLevel');
async function refreshMicStatus(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    chipMic.textContent = 'Mic: unsupported'; return;
  }
  if (navigator.permissions && navigator.permissions.query){
    try{
      const p = await navigator.permissions.query({name:'microphone'});
      chipMic.textContent = 'Mic: ' + p.state;
      p.onchange=()=> chipMic.textContent='Mic: ' + p.state;
      return;
    }catch(e){}
  }
  chipMic.textContent = 'Mic: ready';
}
function refreshSRStatus(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  chipSR.textContent = SR ? 'SR: available' : 'SR: not supported';
}
refreshMicStatus(); refreshSRStatus();

/* ====== Neon waves ====== */
const waves = document.getElementById('waves');
const wctx = waves.getContext('2d');
let waveT=0, waveAmp=0, waveTarget=0;
function sizeWaves(){ waves.width=waves.clientWidth*devicePixelRatio; waves.height=waves.clientHeight*devicePixelRatio; wctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
addEventListener('resize', sizeWaves); sizeWaves();
const lineColors=['rgba(77,207,255,0.22)','rgba(255,92,244,0.22)','rgba(127,255,127,0.20)','rgba(255,209,102,0.20)','rgba(167,139,250,0.22)','rgba(255,133,133,0.20)','rgba(120,170,255,0.22)'];
function drawWaves(){
  const W=waves.clientWidth, H=waves.clientHeight; wctx.clearRect(0,0,W,H);
  waveAmp += (waveTarget - waveAmp)*0.035; const lines=7, baseY=H*0.56, gap=18; wctx.globalCompositeOperation='lighter';
  for(let i=0;i<lines;i++){
    const y0 = baseY + (i-3)*gap, color = lineColors[i%lineColors.length];
    const A = 4 + waveAmp*12, L = W/(1.8 + i*0.12);
    wctx.beginPath();
    for(let x=0;x<=W;x+=8){
      const y = y0 + Math.sin((x/L) + waveT*0.010 + i)*A + Math.sin((x/(L*0.55)) - waveT*0.008)*A*0.35;
      if(x===0) wctx.moveTo(0,y); else wctx.lineTo(x,y);
    }
    wctx.shadowColor=color; wctx.shadowBlur=8; wctx.strokeStyle=color; wctx.lineWidth=1; wctx.stroke();
  }
  wctx.shadowBlur=0; wctx.globalCompositeOperation='source-over'; waveT += 1; requestAnimationFrame(drawWaves);
}
requestAnimationFrame(drawWaves);

/* ====== Cloud orb (main + mini) ====== */
const orb=document.getElementById('orb'), ctx=orb.getContext('2d',{alpha:true});
const miniOrb=document.getElementById('miniOrb'), mctx=miniOrb.getContext('2d',{alpha:true});
let t=0, micLevel=0, speakLevel=0, mode='idle';
const chipState=document.getElementById('chipState'), liveCap=document.getElementById('liveCaption');
const drawerMic=document.getElementById('drawerMic');
function setMode(m){
  mode=m; chipState.textContent=(m==='idle')?'Idle':(m==='listening'?'Listening‚Ä¶':'Speaking‚Ä¶');
  waveTarget=(m==='speaking')?0.55:0;
  drawerMic.textContent=(m==='listening')?'üõë Tap when done':'üéôÔ∏è Tap to speak';
}
function drawCloud(c,W,H,energy,tick){
  const cx=W/2, cy=H/2, baseR=Math.min(W,H)*0.325;
  const breath=0.010*Math.sin(tick*0.45), R=baseR*(1+breath+energy*0.10);
  const k1=5,k2=2,amp1=0.10,amp2=0.035,phase=tick*0.40; const n=36, pts=[];
  for(let i=0;i<n;i++){ const a=i/n*Math.PI*2;
    const lobe=amp1*Math.cos(k1*a+phase)+amp2*Math.cos(k2*a-phase*0.7);
    const reactive=energy*0.05*Math.cos(4*a + tick*0.9);
    const rad=R*(1+lobe+reactive);
    pts.push({x:cx+rad*Math.cos(a), y:cy+rad*Math.sin(a)});
  }
  c.clearRect(0,0,W,H); c.beginPath();
  for(let i=0;i<n;i++){
    const p0=pts[(i-1+n)%n], p1=pts[i], p2=pts[(i+1)%n], p3=pts[(i+2)%n];
    const cp1x=p1.x+(p2.x-p0.x)/6, cp1y=p1.y+(p2.y-p0.y)/6, cp2x=p2.x-(p3.x-p1.x)/6, cp2y=p2.y-(p3.y-p1.y)/6;
    if(i===0) c.moveTo(p1.x,p1.y); c.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
  }
  c.closePath();
  const g=c.createRadialGradient(cx-12,cy-20,R*0.12,cx,cy,R*1.03);
  g.addColorStop(0,'#E8F3FF'); g.addColorStop(0.45,'#EFFEFA'); g.addColorStop(0.82,'#FFFFFF'); g.addColorStop(1,'rgba(255,255,255,0.96)');
  c.fillStyle=g; c.fill(); c.lineWidth=1.1; c.strokeStyle='rgba(170,195,255,.45)'; c.stroke();
}
function animate(){ const energy=Math.min(1, micLevel + speakLevel*0.9); drawCloud(ctx, orb.width, orb.height, energy, t); drawCloud(mctx, miniOrb.width, miniOrb.height, energy, t); t+=0.016; requestAnimationFrame(animate); }
requestAnimationFrame(animate);

/* ====== Browser voices (fallback if server TTS off) ====== */
const voiceNameEl=document.getElementById('voiceName');
const prevVoiceBtn=document.getElementById('prevVoice'), nextVoiceBtn=document.getElementById('nextVoice');
const previewVoiceBtn=document.getElementById('previewVoice'), saveVoiceBtn=document.getElementById('saveVoice');
const Personas=[
  { key:'nova',   label:'Nova (warm, f)',    pitch:1.05, rate:1.00, find:/google.*female|samantha|female|voice\s*1/i, line:"Lovely to meet you. I‚Äôll keep it friendly and clear." },
  { key:'atlas',  label:'Atlas (calm, m)',   pitch:0.95, rate:0.98, find:/google.*male|daniel|male|voice\s*2/i,     line:"Good day. I‚Äôll take a steady, calm approach." },
  { key:'breezy', label:'Breezy (fun, f)',   pitch:1.15, rate:1.06, find:/google.*female|victoria|karen|voice\s*3/i,line:"Oh hey! Let‚Äôs keep this light and fast." },
  { key:'sage',   label:'Sage (informative)',pitch:1.00, rate:0.94, find:/google|english|voice\s*4/i,               line:"Hello. I‚Äôll keep things factual and to the point." },
  { key:'blaze',  label:'Blaze (energetic)', pitch:1.05, rate:1.12, find:/google|english|voice\s*5/i,               line:"Hi! Ready to dive in and get this done!" },
  { key:'pearl',  label:'Pearl (soft, f)',   pitch:1.10, rate:0.93, find:/google.*female|serena|moira|voice\s*6/i,  line:"Hi there‚Äîgentle and clear, at your pace." },
  { key:'orion',  label:'Orion (deep, m)',   pitch:0.85, rate:0.96, find:/google.*male|fred|alex|voice\s*7/i,       line:"Hello. I‚Äôll keep it clear and confident." }
];
let voices=[], personaIndex=0, savedPersonaKey=localStorage.getItem('voice.persona')||'nova';
if ('speechSynthesis' in window){
  const loadVoices=()=>{
    const v=speechSynthesis.getVoices();
    if(!v.length){ setTimeout(loadVoices, 250); return; }
    voices=v; personaIndex=Math.max(0, Personas.findIndex(p=>p.key===savedPersonaKey));
    updateVoiceUI();
  };
  speechSynthesis.onvoiceschanged = loadVoices; loadVoices();
}
function pickVoiceFor(persona){
  let v = voices.find(v=>/google (uk|us) english/i.test(v.name) && /en/i.test(v.lang) && persona.find.test(v.name));
  if (!v) v = voices.find(v=>/google (uk|us) english/i.test(v.name) && /en/i.test(v.lang));
  return v || voices.find(v=>/en(-|_)?/i.test(v.lang)) || voices[0];
}
function currentPersona(){ return Personas[personaIndex]; }
function updateVoiceUI(){
  voiceNameEl.textContent = currentPersona().label;
  saveVoiceBtn.style.display = (currentPersona().key === savedPersonaKey) ? 'none' : 'inline-block';
}
prevVoiceBtn.onclick = ()=>{ personaIndex=(personaIndex-1+Personas.length)%Personas.length; updateVoiceUI(); };
nextVoiceBtn.onclick = ()=>{ personaIndex=(personaIndex+1)%Personas.length; updateVoiceUI(); };
previewVoiceBtn.onclick = ()=>{ speakWithPersona(currentPersona().line, currentPersona(), true); };
saveVoiceBtn.onclick = ()=>{ savedPersonaKey=currentPersona().key; localStorage.setItem('voice.persona', savedPersonaKey); updateVoiceUI(); liveCap.textContent=`Saved voice: ${currentPersona().label}`; };

/* ====== Speak helpers ====== */
let speaking=false, currentAudio=null;
function stopSpeaking(){
  try{ speechSynthesis.cancel(); }catch(e){}
  try{ if (currentAudio){ currentAudio.pause(); currentAudio.src=''; } }catch(e){}
  currentAudio=null; speaking=false; speakLevel=0; setMode('idle');
}
function speak(text){
  const persona = Personas.find(p=>p.key===savedPersonaKey)||currentPersona();
  if (USE_SERVER_TTS){
    API.tts(persona.key, text).then(res=>{
      if (res && res.audio){ playAudioB64(res.audio, text); }
      else { speakWithPersona(text, persona); }
    }).catch(()=> speakWithPersona(text, persona));
  } else {
    speakWithPersona(text, persona);
  }
}
function playAudioB64(b64, transcript){
  stopSpeaking();
  const audio = new Audio('data:audio/mp3;base64,' + b64);
  currentAudio = audio;
  audio.onplay = ()=>{ speaking=true; setMode('speaking'); pulseSpeak(); logTTS(transcript); liveCap.textContent='Agent: ' + transcript; };
  audio.onended=()=>{ speaking=false; setMode('idle'); speakLevel=0; liveCap.textContent='Tap to speak'; currentAudio=null;
                      if (AUTO_TURN_TAKING) setTimeout(()=>{ startListening(); }, TURN_TAKE_DELAY_MS); };
  audio.play().catch(()=>{ speakWithPersona(transcript, currentPersona()); });
}
function speakWithPersona(text, persona, isPreview=false){
  stopSpeaking();
  if (!('speechSynthesis' in window)) return;
  const u=new SpeechSynthesisUtterance(text);
  const v=pickVoiceFor(persona); if (v) u.voice=v; u.pitch=persona.pitch; u.rate=persona.rate;
  u.onstart=()=>{ speaking=true; setMode('speaking'); pulseSpeak(); if(!isPreview){ logTTS(text); } liveCap.textContent='Agent: ' + text; };
  u.onend=()=>{ speaking=false; setMode('idle'); speakLevel=0; if(!isPreview){ liveCap.textContent='Tap to speak'; if (AUTO_TURN_TAKING) setTimeout(()=>{ startListening(); }, TURN_TAKE_DELAY_MS); } };
  speechSynthesis.speak(u);
}
function pulseSpeak(){ if(!speaking) return; const now=performance.now()/1000; speakLevel=0.18+0.14*Math.sin(now*2.6); requestAnimationFrame(pulseSpeak); }

/* ====== First tap: request mic, greet, then auto-listen ====== */
async function primeMicPermission(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return false;
  try{
    const s = await navigator.mediaDevices.getUserMedia({
      audio: { noiseSuppression:true, echoCancellation:true, autoGainControl:true, channelCount:1 }
    });
    s.getTracks().forEach(t=>t.stop());
    chipMic.textContent = 'Mic: granted';
    return true;
  }catch(e){
    chipMic.textContent = 'Mic: denied';
    alert('Please allow microphone (address bar ‚Üí padlock ‚Üí Microphone ‚Üí Allow), then reload.');
    return false;
  }
}

/* ====== Listening + softer VAD (does not stop until speech is heard or hard cap) ====== */
let recognition=null, audioCtx=null, analyser=null, micSrc=null, listening=false, streamRef=null;
let listenStartedAt=0, lastLoudAt=0, heardSpeech=false;
const tapArea=document.getElementById('tap');
let firstTapDone=false;

tapArea.addEventListener('click', async ()=>{
  if (speaking){ stopSpeaking(); startListening(); return; }
  if (!firstTapDone && GREET_ON_FIRST_TAP){
    firstTapDone = true;
    const ok = await primeMicPermission();
    if (!ok) return;
    greet(()=> startListening());
    return;
  }
  listening? stopListening() : startListening();
});
drawerMic.onclick=()=>{ if(speaking){ stopSpeaking(); } listening? stopListening() : startListening(); };

function startListening(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR){
    chipSR.textContent='SR: not supported';
    logBotCard('Speech recognition is not supported in this browser. Please use the text box or try Chrome.');
    return;
  }
  if (listening) return;

  navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
    stopSpeaking();
    streamRef=stream; liveCap.textContent='Listening‚Ä¶ tap when done';
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    if (audioCtx.state==='suspended') audioCtx.resume();
    micSrc = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser(); analyser.fftSize=2048; analyser.smoothingTimeConstant=0.85;
    micSrc.connect(analyser);

    recognition = new SR();
    recognition.lang='en-GB';
    recognition.interimResults=true;
    recognition.maxAlternatives=1;
    recognition.continuous=false;   // let it end on its own when speech ends

    heardSpeech = false;
    listening=true; setMode('listening');
    listenStartedAt=performance.now(); lastLoudAt=listenStartedAt;

    recognition.onaudiostart = ()=> { chipSR.textContent='SR: audio-start'; };
    recognition.onsoundstart = ()=> { chipSR.textContent='SR: sound-start'; };
    recognition.onspeechstart= ()=> { chipSR.textContent='SR: speech-start'; heardSpeech=true; };
    recognition.onspeechend  = ()=> { chipSR.textContent='SR: speech-end'; };
    recognition.onnomatch    = ()=> { logBotCard('I didn‚Äôt catch that.'); };
    recognition.onerror      = (e)=>{
      console.warn('SR error', e.error);
      let msg='Speech recognition error.';
      if (e.error === 'no-speech') msg='No speech heard. Try again closer to the mic.';
      if (e.error === 'audio-capture') msg='No microphone found. Check your mic device.';
      if (e.error === 'not-allowed') msg='Microphone blocked. Click the padlock in the address bar ‚Üí allow microphone, then reload.';
      chipSR.textContent='SR: error ' + e.error;
      logBotCard(msg);
    };
    recognition.onend = ()=>{ stopListening(); };

    recognition.onresult = e => {
      let s=''; for(let i=e.resultIndex;i<e.results.length;i++) s+=e.results[i][0].transcript+' ';
      const text = s.trim();
      liveCap.textContent = text ? ('You: ' + text) : 'Listening‚Ä¶';
      const isFinal = e.results[e.results.length-1].isFinal;
      if (isFinal && text){
        logSTT(text);
        const thinkId = showThinking('Scanning forms and responses‚Ä¶');
        API.nlp(text).then(payload=>{
          doneThinking(thinkId);
          if (!payload){ logBotCard('Could not reach the server.'); speak('Sorry, I could not reach the server.'); return; }
          showPayload(payload);
          speak(payload.summaryLine || 'Done.');
        }).catch(()=>{
          doneThinking(thinkId);
          logBotCard('Network problem talking to the server.');
          speak('There was a network problem talking to the server.');
        });
      }
    };

    try{ recognition.start(); chipSR.textContent='SR: started'; }catch(e){ console.warn(e); chipSR.textContent='SR: failed to start'; }

    meter(); vadLoop();
  }).catch(err=>{
    console.warn(err);
    if (err && (err.name==='NotAllowedError' || err.name==='NotFoundError')){
      alert('Microphone permission is blocked. Click the padlock icon in the address bar ‚Üí allow microphone, then reload.');
      chipMic.textContent='Mic: blocked';
    }
  });
}
function stopListening(){
  if(!listening && !streamRef) { setMode('idle'); return; }
  listening=false; setMode('idle'); micLevel=0; liveCap.textContent='Tap to speak';
  try{ recognition && recognition.stop && recognition.stop(); }catch(e){}
  try{ streamRef && streamRef.getTracks().forEach(t=>t.stop()); }catch(e){}
  streamRef=null;
}
function meter(){
  if (!analyser) return;
  (function loop(){ if(!listening) return;
    const buf=new Float32Array(analyser.fftSize);
    analyser.getFloatTimeDomainData(buf);
    let sum=0; for(let i=0;i<buf.length;i++) sum+=buf[i]*buf[i];
    const rms=Math.sqrt(sum/buf.length);
    const target = Math.max(0, Math.min(1, (rms-MIC_NOISE)*MIC_GAIN));
    micLevel = micLevel*(1-MIC_SMOOTH) + target*MIC_SMOOTH;
    chipLvl.textContent = 'Level: ' + micLevel.toFixed(2);
    if (micLevel > SILENCE_START_THRESHOLD) lastLoudAt = performance.now();
    requestAnimationFrame(loop);
  })();
}
function vadLoop(){
  (function loop(){ if(!listening) return;
    const now=performance.now();
    const timeSinceStart = now - listenStartedAt;
    const longSilent = (now - lastLoudAt) > SILENCE_HOLD_MS;
    const tooLong = timeSinceStart > LISTEN_MAX_MS;

    // If we haven't heard speech yet, don't stop early;
    // give INITIAL_GRACE_MS before we even consider silence.
    if (!heardSpeech){
      if (tooLong){ try{ recognition && recognition.stop && recognition.stop(); }catch(e){} }
    } else {
      if (longSilent || tooLong){ try{ recognition && recognition.stop && recognition.stop(); }catch(e){} }
    }
    requestAnimationFrame(loop);
  })();
}

/* ====== Drawer, chat, greet ====== */
const drawer=document.getElementById('drawer'), openDrawer=document.getElementById('openDrawer'), closeDrawer=document.getElementById('closeDrawer');
openDrawer.onclick=()=>drawer.classList.add('open'); closeDrawer.onclick=()=>drawer.classList.remove('open');

const feed=document.getElementById('feed'), input=document.getElementById('text'), sendBtn=document.getElementById('send'), clearBtn=document.getElementById('clearChat');
const btnPing=document.getElementById('btnPing'), btnSample=document.getElementById('btnSample');

btnPing.onclick=()=>{ const id=showThinking('Pinging API‚Ä¶'); API.meta().then(m=>{ doneThinking(id); logBotCard('API OK ‚Ä¢ timezone: ' + (m?.timezone||'n/a')); }); };
btnSample.onclick=()=>{ const q='check cowley forms for last week'; logSTT(q);
  const id=showThinking('Scanning forms‚Ä¶'); API.nlp(q).then(p=>{ doneThinking(id); if(!p){ logBotCard('Server error.'); speak('Server error.'); return;}
  showPayload(p); speak(p.summaryLine||'Done.'); }).catch(()=>{ doneThinking(id); logBotCard('Network problem.'); speak('Network problem.'); });
};

sendBtn.onclick=()=>{ if(!input.value.trim()) return; const q=input.value.trim(); logSTT(q);
  const id = showThinking('Scanning forms and responses‚Ä¶');
  API.nlp(q).then(payload=>{
    doneThinking(id);
    if (!payload){ logBotCard('Could not reach the server.'); speak('Sorry, I could not reach the server.'); return; }
    showPayload(payload);
    speak(payload.summaryLine || 'Done.');
  }).catch(()=>{ doneThinking(id); logBotCard('Network problem talking to the server.'); speak('There was a network problem talking to the server.'); });
  input.value='';
};
input.addEventListener('keydown',e=>{ if(e.key==='Enter') sendBtn.click(); });
clearBtn.onclick=()=>{ if (confirm('Clear chat history?')) { localStorage.removeItem('chat.feed'); feed.innerHTML=''; } };
function push(html){ feed.insertAdjacentHTML('beforeend', html); feed.scrollTop=feed.scrollHeight; localStorage.setItem('chat.feed', feed.innerHTML); }
function logSTT(text){ push(`<div class="card"><b>You said</b><div class="muted" style="margin-top:4px">${escapeHtml(text)}</div></div>`); }
function logTTS(text){ push(`<div class="card"><b>Agent</b><div class="muted" style="margin-top:4px">${escapeHtml(text)}</div></div>`); }
function logBotCard(msg){ push(`<div class="card"><b>Agent</b><div class="muted" style="margin-top:4px">${escapeHtml(msg)}</div></div>`); }

const tzChip=document.getElementById('chipTZ');
API.meta().then(m=>{ tzChip.textContent=`Timezone: ${m?.timezone||'Europe/London'}`; });

function greet(after){
  const now=new Date();
  const lines=[
    "Hi! Tell me a location or form and I‚Äôll look for any missed submissions.",
    "Hello! I can scan opening, closing, and temperature forms ‚Äî just say the word.",
    "Hey there! Ask me for a location or form and I‚Äôll check it."
  ];
  const line = `${lines[Math.floor(Math.random()*lines.length)]} It‚Äôs ${now.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} on ${now.toLocaleDateString([], {weekday:'long', month:'short', day:'numeric'})}. You can interrupt by speaking anytime.`;
  logTTS(line); speak(line);
  if (after) setTimeout(()=>{ try{ after(); }catch(e){} }, 1200);
}

/* ====== ‚ÄúWorking‚Ä¶‚Äù card ====== */
let thinkingCardId=0;
function showThinking(msg='Scanning forms‚Ä¶'){
  const id=++thinkingCardId;
  push(`<div class="card" id="think_${id}"><b>Working</b><div class="muted" style="margin-top:4px">${escapeHtml(msg)}</div></div>`);
  return id;
}
function doneThinking(id, replaceHtml){
  const el=document.getElementById(`think_${id}`);
  if (!el) return;
  if (replaceHtml) el.outerHTML = replaceHtml; else el.remove();
}

/* ====== Render payload ====== */
function showPayload(payload){
  const { queryParsed, summary, results } = payload;
  const hdr = `<div class="card"><div><b>Range:</b> ${summary.range.startISO.slice(0,10)} ‚Üí ${summary.range.endISO.slice(0,10)}</div>
    ${queryParsed.business? `<div><b>Business:</b> ${escapeHtml(queryParsed.business)}</div>`:''}
    ${queryParsed.location? `<div><b>Location:</b> ${escapeHtml(queryParsed.location)}</div>`:''}
    ${queryParsed.formName? `<div><b>Form:</b> ${escapeHtml(queryParsed.formName)}</div>`:''}
    ${queryParsed.staffName? `<div><b>Staff:</b> ${escapeHtml(queryParsed.staffName)}</div>`:''}
    <div class="muted">${summary.counts.missed} missed ¬∑ ${summary.counts.submitted} submitted ¬∑ ${summary.counts.upcoming} upcoming</div></div>`;
  push(hdr);

  const missed=results.filter(r=>r.status==='missed' || r.status==='missed-by-staff');
  if (missed.length){
    push(`<div class="grid">${missed.map(r=>card(r,'‚ùå Missed')).join('')}</div>`);
  } else {
    push(`<div class="card">‚úÖ No missed slots in this range.</div>`);
  }

  const recent=results.filter(r=>r.status==='submitted').slice(-6);
  if (recent.length){
    push(`<div class="muted" style="margin-top:8px">Recent submissions</div>`);
    push(`<div class="grid">${recent.map(r=>card(r,'‚úÖ Submitted')).join('')}</div>`);
  }
}
function card(r,badge){
  const due=new Date(r.dueISO);
  const when=due.toLocaleString(undefined,{weekday:'short',day:'2-digit',month:'short',hour:'2-digit',minute:'2-digit'});
  const sub=r.foundSubmissionAtISO?new Date(r.foundSubmissionAtISO).toLocaleString():'';
  const who=r.submitter?` ‚Ä¢ by ${escapeHtml(r.submitter)}`:'';
  return `<div class="card"><div><b>${badge}</b></div><div>${escapeHtml(r.location)}</div>
    <div>${escapeHtml(r.formName)} <span class="pill">${escapeHtml(r.slotLabel)}</span></div>
    <div class="muted">Due: ${when}</div><div class="muted">Status: ${r.status}${who}${sub?' ¬∑ submitted at '+sub:''}</div>
    <div class="muted"><a target="_blank" href="${r.formUrl}">Open form</a> ¬∑ <a target="_blank" href="${r.responsesUrl}">Responses sheet</a></div></div>`;
}

/* ====== Safe escape ====== */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[m]));
}
</script>
</body>
</html>
